# 5.12 Command handler
# Напишите программу, имитирующую обработчик команд от пользователя.
# Программа должна выводить оповещение о своём состоянии в следующем формате:
# Когда пользователь вводит команду, содержимое которой обозначим как <command>, программа должна
# вывести фразу
# Processing "<command>" command...
# Например, пользователь ввёл Come to me, в таком случае должна быть выведена строка
# Processing "Come to me" command...
# Считывание команд должно продолжаться до ввода команды End, при этом программа должна вывести сообщение
# Good bye! и завершиться
# Для считывания команд используйте функцию input без аргументов.
# Формат ввода:
# Последовательность команд, каждая на отдельной строке. Команда состоит из символов латинского
# алфавита, пробелов и символов табуляции. Гарантируется отсутствие пробельных символов в начале и
# конце строки. Последняя команда всегда End.
#
# Формат вывода:
# Сообщения об обработке команд, как указано в задании, по одному сообщению на строку.

# while True:
#     command = input()
#     if command == 'End':
#         print('Good bye!')
#         break
#     else:
#         print('Processing \"' + command + '\" command...')
# ---------------------------------------------------------------------------------------------------
# 4.3 Caesar cipher
# Шифр Цезаря заключается в замене каждого символа входной строки на символ, находящийся на несколько
# позиций левее или правее его в алфавите.
# Для всех символов сдвиг один и тот же. Сдвиг циклический, т.е. если к последнему символу алфавита
# применить единичный сдвиг, то он заменится на первый символ, и наоборот.
# Напишите программу, которая шифрует текст шифром Цезаря.
# Используемый алфавит − - − пробел и малые символы латинского алфавита: ' abcdefghijklmnopqrstuvwxyz'
# Формат ввода:
# На первой строке указывается используемый сдвиг шифрования: целое число. Положительное
# число соответствует сдвигу вправо. На второй строке указывается непустая фраза для шифрования.
# Ведущие и завершающие пробелы не учитывать.
# Формат вывода:
# Единственная строка, в которой записана фраза: Result: "..." , где вместо многоточия внутри
# кавычек записана зашифрованная последовательность.
# abc = ' abcdefghijklmnopqrstuvwxyz'
# shift = int(input())
# string = input().lstrip().rstrip()
# result = ''
# for char in string:
#     result += abc[(abc.index(char) + shift) % len(abc)]
# print('Result: "' + result + '"')
# -----------------------------------------------------------------------------------------------------

# 3.9 Duplicates in list
# Напишите программу, которая принимает на вход список целых чисел и выводит на экран значения,
# которые повторяются в нём более одного раза.
# Для решения задачи может пригодиться метод sort списка.
# Формат ввода:
# Одна строка с целыми числами, разделёнными пробелом.
# Формат вывода:
# Строка, содержащая числа, разделённые пробелом. Числа не должны повторяться, порядок вывода
# может быть произвольным.
# lst = [int(i) for i in input().split()]
# lst.sort()
# cnt = 0
# while cnt < len(lst):
#     step = lst.count(lst[cnt])
#     if step > 1:
#         print(lst[cnt], end=' ')
#     cnt += step
# -----------------------------------------------------------------------------------------------

# 3.7 Multiple list index search
# Напишите программу, которая принимает на вход список чисел и число, после чего выводит все
# позиции, на которых это число встречается в переданном списке.
# # Позиции в списке нумеруются с нуля.
# Если число x не найдено в списке, нужно вывести строку "None" (без кавычек, с большой буквы).
# Формат ввода:
# На первой строке содержатся значения списка -- целые числа, разделённые пробелом.
# На второй строке содержится целое число, позиции которого нужно найти.
# Формат вывода:
# Одна строка, в которой содержится слово "None" или через пробел перечислены числа -- позиции,
# на которых число x встречается в списке lst. Позиции должны быть выведены в порядке возрастания.

# lst = [int(i) for i in input().split()]
# num = int(input())
# cnt = lst.count(num)
# if cnt == 0:
#     print('None')
# else:
#     pos = -1
#     for i in range(cnt):
#         pos = lst.index(num, pos + 1)
#         print(pos, end=' ')

# 5.13 Length statistic
# На вход программе подаётся строка, содержащая слова, разделённые пробелом. Программа должна
# вывести статистику длин слов в полученной строке, от меньшей длины слова к большей (см. пример).
# Словом считается последовательность произвольных символов, окружённая пробелами либо границами
# строки. Заметьте, что знаки препинания также относятся к слову.
# Формат ввода:
# Одна строка, содержащая последовательности латинских символов и знаков препинания, разделённые пробелом.
# Формат вывода:
# Для каждой длины слова, встречающейся в исходной строке, нужно указать количество слов с такой длиной
# длина: количество
# Статистика должна выводиться в порядке увеличения длины.
# lst = input().split()
# result = {}
# for word in lst:
#     result.setdefault(len(word))
#     if result[len(word)] is None:
#         result[len(word)] = 1
#     else:
#         result[len(word)] += 1
# for key in sorted(result):
#     print('%s: %s' % (key, result[key]))
# ------------------------------------------------------------------------------------------------

# 4.2 Base RLE decode
# Кодирование длин серий — это базовый алгоритм сжатия данных.
# В этой задаче мы реализуем алгоритм дешифровки строк, закодированных с помощью одного из
# самых простых  вариантов кодирования длин серий.
# На вход алгоритму подаётся строка, содержащая цифры и символы латинского алфавита. Эта строка
# разбивается на так называемые "серии", которые кодируются парой число-символ или просто символ
# (в таком случае число считается равным единице). Результат должен содержать эти серии в том же
# порядке, что они и встречаются в исходной строке, при этом каждая серия раскрывается в
# последовательность символов соответствующей длины.
# Например, рассмотрим строку 3ab4c2CaB
# Разобъём её на серии 3a b 4c 2C a B
# После чего преобразуем серии и получим исходную закодированную строку:  aaabccccCCaB
# # Формат ввода:
# Одна строка, содержащая закодированную последовательность.
# # Формат вывода:
# Строка, содержащая раскодированную последовательность.

s = input()
i = 0
while i < len(s):
    if s[i].isdigit():
        length = ''
        while s[i].isdigit() and i < len(s):
            length += s[i]
            i += 1
    else:
        length = '1'
    print(s[i]*int(length), end='')
    i += 1
