# 5.12 Command handler
# Напишите программу, имитирующую обработчик команд от пользователя.
# Программа должна выводить оповещение о своём состоянии в следующем формате:
# Когда пользователь вводит команду, содержимое которой обозначим как <command>, программа должна
# вывести фразу
# Processing "<command>" command...
# Например, пользователь ввёл Come to me, в таком случае должна быть выведена строка
# Processing "Come to me" command...
# Считывание команд должно продолжаться до ввода команды End, при этом программа должна вывести сообщение
# Good bye! и завершиться
# Для считывания команд используйте функцию input без аргументов.
# Формат ввода:
# Последовательность команд, каждая на отдельной строке. Команда состоит из символов латинского
# алфавита, пробелов и символов табуляции. Гарантируется отсутствие пробельных символов в начале и
# конце строки. Последняя команда всегда End.
#
# Формат вывода:
# Сообщения об обработке команд, как указано в задании, по одному сообщению на строку.

# while True:
#     command = input()
#     if command == 'End':
#         print('Good bye!')
#         break
#     else:
#         print('Processing \"' + command + '\" command...')
# ---------------------------------------------------------------------------------------------------
# 4.3 Caesar cipher
# Шифр Цезаря заключается в замене каждого символа входной строки на символ, находящийся на несколько
# позиций левее или правее его в алфавите.
# Для всех символов сдвиг один и тот же. Сдвиг циклический, т.е. если к последнему символу алфавита
# применить единичный сдвиг, то он заменится на первый символ, и наоборот.
# Напишите программу, которая шифрует текст шифром Цезаря.
# Используемый алфавит − - − пробел и малые символы латинского алфавита: ' abcdefghijklmnopqrstuvwxyz'
# Формат ввода:
# На первой строке указывается используемый сдвиг шифрования: целое число. Положительное
# число соответствует сдвигу вправо. На второй строке указывается непустая фраза для шифрования.
# Ведущие и завершающие пробелы не учитывать.
# Формат вывода:
# Единственная строка, в которой записана фраза: Result: "..." , где вместо многоточия внутри
# кавычек записана зашифрованная последовательность.
# abc = ' abcdefghijklmnopqrstuvwxyz'
# shift = int(input())
# string = input().lstrip().rstrip()
# result = ''
# for char in string:
#     result += abc[(abc.index(char) + shift) % len(abc)]
# print('Result: "' + result + '"')
# -----------------------------------------------------------------------------------------------------

# 3.9 Duplicates in list
# Напишите программу, которая принимает на вход список целых чисел и выводит на экран значения,
# которые повторяются в нём более одного раза.
# Для решения задачи может пригодиться метод sort списка.
# Формат ввода:
# Одна строка с целыми числами, разделёнными пробелом.
# Формат вывода:
# Строка, содержащая числа, разделённые пробелом. Числа не должны повторяться, порядок вывода
# может быть произвольным.
# digits = [int(i) for i in input().split()]
# digits.sort()
# cnt = 0
# while cnt < len(digits):
#     step = digits.count(digits[cnt])
#     if step > 1:
#         print(digits[cnt], end=' ')
#     cnt += step
# -----------------------------------------------------------------------------------------------

# 3.7 Multiple list index search
# Напишите программу, которая принимает на вход список чисел и число, после чего выводит все
# позиции, на которых это число встречается в переданном списке.
# # Позиции в списке нумеруются с нуля.
# Если число x не найдено в списке, нужно вывести строку "None" (без кавычек, с большой буквы).
# Формат ввода:
# На первой строке содержатся значения списка -- целые числа, разделённые пробелом.
# На второй строке содержится целое число, позиции которого нужно найти.
# Формат вывода:
# Одна строка, в которой содержится слово "None" или через пробел перечислены числа -- позиции,
# на которых число x встречается в списке digits. Позиции должны быть выведены в порядке возрастания.

# digits = [int(i) for i in input().split()]
# num = int(input())
# cnt = digits.count(num)
# if cnt == 0:
#     print('None')
# else:
#     pos = -1
#     for i in range(cnt):
#         pos = digits.index(num, pos + 1)
#         print(pos, end=' ')

# 5.13 Length statistic
# На вход программе подаётся строка, содержащая слова, разделённые пробелом. Программа должна
# вывести статистику длин слов в полученной строке, от меньшей длины слова к большей (см. пример).
# Словом считается последовательность произвольных символов, окружённая пробелами либо границами
# строки. Заметьте, что знаки препинания также относятся к слову.
# Формат ввода:
# Одна строка, содержащая последовательности латинских символов и знаков препинания, разделённые пробелом.
# Формат вывода:
# Для каждой длины слова, встречающейся в исходной строке, нужно указать количество слов с такой длиной
# длина: количество
# Статистика должна выводиться в порядке увеличения длины.
# digits = input().split()
# result = {}
# for word in digits:
#     result.setdefault(len(word))
#     if result[len(word)] is None:
#         result[len(word)] = 1
#     else:
#         result[len(word)] += 1
# for key in sorted(result):
#     print('%s: %s' % (key, result[key]))
# ------------------------------------------------------------------------------------------------

# 4.2 Base RLE decode
# Кодирование длин серий — это базовый алгоритм сжатия данных.
# В этой задаче мы реализуем алгоритм дешифровки строк, закодированных с помощью одного из
# самых простых  вариантов кодирования длин серий.
# На вход алгоритму подаётся строка, содержащая цифры и символы латинского алфавита. Эта строка
# разбивается на так называемые "серии", которые кодируются парой число-символ или просто символ
# (в таком случае число считается равным единице). Результат должен содержать эти серии в том же
# порядке, что они и встречаются в исходной строке, при этом каждая серия раскрывается в
# последовательность символов соответствующей длины.
# Например, рассмотрим строку 3ab4c2CaB
# Разобъём её на серии 3a b 4c 2C a B
# После чего преобразуем серии и получим исходную закодированную строку:  aaabccccCCaB
# # Формат ввода:
# Одна строка, содержащая закодированную последовательность.
# # Формат вывода:
# Строка, содержащая раскодированную последовательность.
#
# s = input()
# i = 0
# while i < len(s):
#     if s[i].isdigit():
#         length = ''
#         while s[i].isdigit() and i < len(s):
#             length += s[i]
#             i += 1
#     else:
#         length = '1'
#     print(s[i]*int(length), end='')
#     i += 1
# --------------------------------------------------------------------------------------------
# 4.1 Base RLE encode
# На вход алгоритму подаётся строка, содержащая символы латинского алфавита. Эта строка
# разбивается на группы одинаковых символов, идущих подряд ("серии"). Каждая серия
# характеризуется повторяющимся символом и количеством повторений. Именно эта информация
# и записывается в код: сначала пишется длина серии повторяющихся символов, затем сам символ.
# У серий длиной в один символ количество повторений будем опускать.
# Формат ввода:
# Одна строка, содержащая произвольные символы латинского алфавита.
#
# Формат вывода:
# Строка, содержащая закодированную последовательность.
# s = input()
# l = len(s)
# i = 0
# while i < l:
#     cnt = 1
#     while i + cnt < l and s[i] == s[i + cnt]:
#         cnt += 1
#     if cnt > 1:
#         print(cnt, end='')
#     print(s[i], end='')
#     i += cnt
# ---------------------------------------------------------------------------------------------

# 9.1 Durak
# A durak deck contains 36 cards. Each card has a suit of either clubs, diamonds, hearts,
# or spades (denoted C, D, H, S). Each card also has a value of either 6 through 10, jack,
# queen, king, or ace (denoted 6, 7, 8, 9, 10, J, Q, K, A). For scoring purposes card values
# are ordered as above, with 6 having the lowest and ace the highest value.
# # Напишите программу, которая определяет, бьёт ли одна карта другую.
# Если встречаются две карты одной масти, то побеждает та, у которой выше значение;
# Если карты разных мастей, то карта, имеющая козырную масть, побеждает;
# Если карты разных мастей и нет козырных, то никто не побеждает.
# # Формат ввода:
# На первой строке через пробел указываются две карты в формате <значение><масть>, а на
# следующей строке указывается козырная масть.
# # Формат вывода:
# Программа должна вывести слово
# First, если первая карта бьёт вторую,
# Second, если вторая карта бьёт первую,
# Error, если ни одна из карт не может побить другую.
# deck = ['6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A']
# result = 'Error'
# first, second = input().split()
# suit = input()
# if first[-1] == second[-1]:
#     if deck.index(first[:-1]) - deck.index(second[:-1]) > 0:
#         result = 'First'
#     else:
#         result = 'Second'
# else:
#     if first[-1] == suit:
#         result = 'First'
#     elif second[-1] == suit:
#         result = 'Second'
# print(result)
# --------------------------------------------------------------------------------------------------
# 5.9 Fizz Buzz
# Напишите программу, которая принимает на вход два целых числа: начало и конец отрезка (оба числа
# входят в отрезок).
# Программа должна вывести числа из этого отрезка, но если число делится на 3, то вывести вместо него
# Fizz, если число делится на 5, вывести вместо него Buzz, а если делится и на три, и на 5, то
# вывести вместо этого числа FizzBuzz.
# Формат ввода:
# Два целых числа через пробел.
# Формат вывода:
# На отдельной строке каждое число из отрезка или слово, его заменяющее.
s = input().split()
for i in range(int(s[0]), int(s[1]) + 1, 1):
    if i % 3 != 0 and i % 5 != 0:
        print(i)
        continue
    elif i % 3 == 0 and i % 5 == 0:
        print('FizzBuzz')
        continue
    if i % 3 == 0:
        print('Fizz')
    else:
        print('Buzz')
