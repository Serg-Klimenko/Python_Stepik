# 1.2.1 Реализуйте программу, которая будет вычислять количество различных объектов в списке.
# Два объекта a и b считаются различными, если a is b равно False. Вашей программе доступна
# переменная с названием objects, которая ссылается на список, содержащий не более 100 объектов.
# Выведите количество различных объектов в этом списке.

# objects = [1, True, 1, 2, 3, False, 'end']
# result = set()
# ans = 0
# for obj in objects:
#     if id(obj) not in result:
#         result.add(id(obj))
#         ans += 1
# print(ans)
# ----------------------------------------------------------------------------------------------

# 1.3.1 Напишите реализацию функции closest_mod_5, принимающую в качестве единственного
# аргумента целое число x и возвращающую самое маленькое целое число y, такое что:
#     y больше или равно x
#     y делится нацело на 5
# Формат того, что ожидается от вас в качестве ответа:
# def closest_mod_5(x):
#    if x % 5 == 0:
#        return x
#    return "I don't know :("
#
# def closest_mod_5(x):
#     if x % 5 == 0:
#         return x
#     else:
#         return x + (5 - (x % 5))
#
#
# print(closest_mod_5(8))
# --------------------------------------------------------------------------------------------------
# 1.3.2 В результате каких вызовов данная функция вернет число 31?
# def s(a, *vs, b=10):
#     res = a + b
#     for v in vs:
#         res += v
#     return res
#
#
# print('s(11, 10, 10): ', s(11, 10, 10))
# print('s(11, 10): ', s(11, 10))
# print('s(5, 5, 5, 5, 1): ', s(5, 5, 5, 5, 1))
# print('s(21): ', s(21))
# print('s(11, b=20): ', s(11, b=20))
# # print('s(b=31): ', s(b=31))
# print('s(0, 0, 31): ', s(0, 0, 31))
# print('s(11, 10, b=10): ', s(11, 10, b=10))
# # print('s(b=31, 0): ', s(b=31, 0))
# --------------------------------------------------------------------------------------------

# 1.3.1 Сочетанием из n элементов по k называется подмножество этих n элементов размера k.
# Два сочетания называются различными, если одно из сочетаний содержит элемент, который не
# содержит другое. Числом сочетаний из n по k называется количество различных сочетаний из
# n по k. Обозначим это число за C(n, k).
# # Пример:
# Пусть n = 3, т. е. есть три элемента (1, 2, 3). Пусть k = 2.
# Все различные сочетания из 3 элементов по 2: (1, 2), (1, 3), (2, 3).
# Различных сочетаний три, поэтому C(3, 2) = 3.
# Несложно понять, что C(n, 0) = 1, так как из n элементов выбрать 0 можно единственным образом,
# а именно, ничего не выбрать. Также несложно понять, что если k > n, то C(n, k) = 0, так как
# невозможно, например, из трех элементов выбрать пять.
# # Для вычисления C(n, k) в других случаях используется следующая рекуррентная формула:
# C(n, k) = C(n - 1, k) + C(n - 1, k - 1).
# # Реализуйте программу, которая для заданных n и k вычисляет C(n, k).
# # Вашей программе на вход подается строка, содержащая два целых числа n и k (1 ≤ n ≤ 10, 0 ≤ k ≤ 10).
# Ваша программа должна вывести единственное число: C(n, k).
# Считать два числа n и k вы можете, например, следующим образом:  n, k = map(int, input().split())
# def count_lots(n, k):
#     if k > n:
#         return 0
#     elif k == 0:
#         return 1
#     else:
#         return count_lots(n - 1, k) + count_lots(n - 1, k - 1)
#
#
# n, k = map(int, input().split())
# print(count_lots(n, k))
# --------------------------------------------------------------------------------------------------

# 1.4.1 Реализуйте программу, которая будет эмулировать работу с пространствами имен. Необходимо
# реализовать поддержку создания пространств имен и добавление в них переменных.
# В данной задаче у каждого пространства имен есть уникальный текстовый идентификатор – его имя.
# Вашей программе на вход подаются следующие запросы:
#     create <namespace> <parent> –  создать новое пространство имен с именем <namespace> внутри
#                                       пространства <parent>
#     add <namespace> <var> – добавить в пространство <namespace> переменную <var>
#     get <namespace> <var> – получить имя пространства, из которого будет взята переменная
#                               <var> при запросе из пространства <namespace>, или None, если
#                               такого пространства не существует
# Рассмотрим набор запросов
#     add global a
#     create foo global
#     add foo b
#     create bar foo
#     add bar a
# Структура пространств имен описанная данными запросами будет эквивалентна структуре пространств
# имен, созданной при выполнении данного кода
# a = 0
# def foo():
#   b = 1
#   def bar():
#     a = 2
# В основном теле программы мы объявляем переменную a, тем самым добавляя ее в пространство
# global. Далее мы объявляем функцию foo, что влечет за собой создание локального для нее
# пространства имен внутри пространства global. В нашем случае, это описывается командой
# create foo global. Далее мы объявляем внутри функции foo функцию bar, тем самым создавая
# пространство bar внутри пространства foo, и добавляем в bar переменную a.
# Добавим запросы get к нашим запросам
#     get foo a
#     get foo c
#     get bar a
#     get bar b
# Представим как это могло бы выглядеть в коде
# a = 0
# def foo():
#   b = 1
#   get(a)
#   get(c)
#   def bar():
#     a = 2
#     get(a)
#     get(b)
# Результатом запроса get будет имя пространства, из которого будет взята нужная переменная.
# Например, результатом запроса get foo a будет global, потому что в пространстве foo не объявлена
# переменная a, но в пространстве global, внутри которого находится пространство foo, она объявлена.
# Аналогично, результатом запроса get bar b будет являться foo, а результатом работы get bar a
# будет являться bar.
# Результатом get foo c будет являться None, потому что ни в пространстве foo, ни в его внешнем
# пространстве global не была объявлена переменная с.
# Более формально, результатом работы get <namespace> <var> является
#     <namespace>, если в пространстве <namespace> была объявлена переменная <var>
#     get <parent> <var> – результат запроса к пространству, внутри которого было создано
#                           пространство <namespace>, если переменная не была объявлена
#     None, если не существует <parent>, т. е. <namespace> – это global
# Формат входных данных
# В первой строке дано число n (1 ≤ n ≤ 100) – число запросов.
# В каждой из следующих n строк дано по одному запросу.
# Запросы выполняются в порядке, в котором они даны во входных данных.
# Имена пространства имен и имена переменных представляют из себя строки длины не более 10,
# состоящие из строчных латинских букв.
# Формат выходных данных
# Для каждого запроса get выведите в отдельной строке его результат.
